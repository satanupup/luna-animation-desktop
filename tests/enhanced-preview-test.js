/**
 * üîÑ ÁíêÂ®úÁöÑ GIF ÂãïÁï´Ë£Ω‰ΩúÂô® - Â¢ûÂº∑È†êË¶ΩÊ∏¨Ë©¶
 * 
 * Â∞àÈñÄÊ∏¨Ë©¶È†êË¶ΩÊõ¥Êñ∞ÂäüËÉΩÂíåÊâÄÊúâÊñ∞Â¢ûÁöÑÊéßÂà∂È†Ö
 */

const { chromium } = require('playwright');
const path = require('path');
const fs = require('fs');

class EnhancedPreviewTest {
    constructor() {
        this.browser = null;
        this.page = null;
        this.testResults = {
            previewUpdates: {},
            controlTests: {},
            performanceTests: {},
            issues: [],
            summary: {}
        };
        this.startTime = Date.now();
    }

    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const prefix = {
            'info': 'üìã',
            'success': '‚úÖ',
            'warning': '‚ö†Ô∏è',
            'error': '‚ùå',
            'test': 'üß™',
            'preview': 'üîÑ'
        }[type] || 'üìã';
        
        console.log(`[${timestamp}] ${prefix} ${message}`);
    }

    async runTests() {
        this.log('ÈñãÂßãÂ¢ûÂº∑È†êË¶ΩÊ∏¨Ë©¶...', 'test');
        
        try {
            await this.setupBrowser();
            await this.loadApplication();
            await this.testPreviewUpdates();
            await this.testAllControls();
            await this.testPerformance();
            await this.generateReport();
        } catch (error) {
            this.log(`Ê∏¨Ë©¶ÈÅéÁ®ãÁôºÁîüÈåØË™§: ${error.message}`, 'error');
            this.testResults.issues.push({
                type: 'critical',
                message: error.message,
                stack: error.stack
            });
        } finally {
            await this.cleanup();
        }
    }

    async setupBrowser() {
        this.log('ÂïüÂãïÁÄèË¶ΩÂô®...', 'info');
        this.browser = await chromium.launch({ 
            headless: false,
            slowMo: 100 // Ê∏õÊÖ¢Êìç‰Ωú‰ª•‰æøËßÄÂØü
        });
        this.page = await this.browser.newPage();
        
        // Ë®≠ÁΩÆË¶ñÁ™óÂ§ßÂ∞è
        await this.page.setViewportSize({ width: 1200, height: 800 });
    }

    async loadApplication() {
        this.log('ËºâÂÖ•ÊáâÁî®Á®ãÂºè...', 'info');
        const appPath = path.join(__dirname, '..', 'src', 'index.html');
        await this.page.goto(`file://${appPath}`);
        
        // Á≠âÂæÖÊáâÁî®Á®ãÂºèËºâÂÖ•ÂÆåÊàê
        await this.page.waitForSelector('#canvas', { timeout: 10000 });
        await this.page.waitForTimeout(2000); // Á≠âÂæÖÂãïÁï´ÂºïÊìéÂàùÂßãÂåñ
        
        this.log('ÊáâÁî®Á®ãÂºèËºâÂÖ•ÂÆåÊàê', 'success');
    }

    async testPreviewUpdates() {
        this.log('Ê∏¨Ë©¶È†êË¶ΩÊõ¥Êñ∞ÂäüËÉΩ...', 'preview');
        
        const controls = [
            { id: 'shape', type: 'select', values: ['circle', 'square', 'triangle'] },
            { id: 'fillColor', type: 'color', values: ['#ff0000', '#00ff00', '#0000ff'] },
            { id: 'strokeColor', type: 'color', values: ['#000000', '#ffffff', '#ff00ff'] },
            { id: 'size', type: 'range', values: [20, 50, 80] },
            { id: 'filled', type: 'checkbox', values: [true, false] },
            { id: 'strokeWidth', type: 'range', values: [1, 4, 8] },
            { id: 'animationMode', type: 'select', values: ['loop', 'enter-exit', 'enter-only'] },
            { id: 'animationType', type: 'select', values: ['bounce', 'slide', 'fade', 'zoom'] },
            { id: 'speed', type: 'range', values: [500, 1000, 2000] },
            { id: 'duration', type: 'range', values: [1, 3, 5] },
            { id: 'loops', type: 'select', values: ['infinite', '3', '5'] },
            { id: 'delay', type: 'range', values: [0, 500, 1000] },
            { id: 'rotation', type: 'range', values: [0, 90, 180] },
            { id: 'quality', type: 'select', values: ['12', '15', '20'] }
        ];

        for (const control of controls) {
            await this.testControlPreview(control);
        }
    }

    async testControlPreview(control) {
        this.log(`Ê∏¨Ë©¶ ${control.id} ÊéßÂà∂È†ÖÈ†êË¶ΩÊõ¥Êñ∞...`, 'test');
        
        try {
            const element = await this.page.$(`#${control.id}`);
            if (!element) {
                this.testResults.issues.push({
                    type: 'error',
                    message: `ÊéßÂà∂È†Ö ${control.id} ‰∏çÂ≠òÂú®`
                });
                return;
            }

            const results = [];
            
            for (const value of control.values) {
                // Ë®òÈåÑËÆäÊõ¥ÂâçÁöÑÁï´Â∏ÉÁãÄÊÖã
                const beforeCanvas = await this.getCanvasState();
                
                // ËÆäÊõ¥ÊéßÂà∂È†ÖÂÄº
                await this.setControlValue(control.id, control.type, value);
                
                // Á≠âÂæÖÈ†êË¶ΩÊõ¥Êñ∞
                await this.page.waitForTimeout(500);
                
                // Ë®òÈåÑËÆäÊõ¥ÂæåÁöÑÁï´Â∏ÉÁãÄÊÖã
                const afterCanvas = await this.getCanvasState();
                
                // Ê™¢Êü•ÊòØÂê¶ÊúâËÆäÂåñ
                const hasChanged = beforeCanvas !== afterCanvas;
                
                results.push({
                    value: value,
                    previewUpdated: hasChanged,
                    timestamp: Date.now()
                });
                
                this.log(`  ${control.id} = ${value}: ${hasChanged ? '‚úÖ È†êË¶ΩÂ∑≤Êõ¥Êñ∞' : '‚ùå È†êË¶ΩÊú™Êõ¥Êñ∞'}`, hasChanged ? 'success' : 'error');
                
                if (!hasChanged) {
                    this.testResults.issues.push({
                        type: 'warning',
                        message: `ÊéßÂà∂È†Ö ${control.id} ÂÄº ${value} Êú™Ëß∏ÁôºÈ†êË¶ΩÊõ¥Êñ∞`
                    });
                }
            }
            
            this.testResults.previewUpdates[control.id] = {
                type: control.type,
                results: results,
                successRate: results.filter(r => r.previewUpdated).length / results.length
            };
            
        } catch (error) {
            this.log(`Ê∏¨Ë©¶ ${control.id} ÊôÇÁôºÁîüÈåØË™§: ${error.message}`, 'error');
            this.testResults.issues.push({
                type: 'error',
                message: `ÊéßÂà∂È†Ö ${control.id} Ê∏¨Ë©¶Â§±Êïó: ${error.message}`
            });
        }
    }

    async setControlValue(id, type, value) {
        const element = await this.page.$(`#${id}`);
        
        switch (type) {
            case 'select':
                await element.selectOption(value);
                break;
            case 'range':
                await element.fill(value.toString());
                break;
            case 'color':
                await element.fill(value);
                break;
            case 'checkbox':
                if (value) {
                    await element.check();
                } else {
                    await element.uncheck();
                }
                break;
        }
        
        // Ëß∏Áôº change/input ‰∫ã‰ª∂
        await element.dispatchEvent('input');
        await element.dispatchEvent('change');
    }

    async getCanvasState() {
        // Áç≤ÂèñÁï´Â∏ÉÁöÑÁï∂ÂâçÁãÄÊÖãÔºàÂèØ‰ª•ÊòØÊà™ÂúñÁöÑ hash ÊàñÂÖ∂‰ªñÂîØ‰∏ÄÊ®ôË≠òÔºâ
        return await this.page.evaluate(() => {
            const canvas = document.getElementById('canvas');
            if (canvas) {
                return canvas.toDataURL();
            }
            return null;
        });
    }

    async testAllControls() {
        this.log('Ê∏¨Ë©¶ÊâÄÊúâÊéßÂà∂È†ÖÂäüËÉΩ...', 'test');
        
        const controlTests = [
            { name: 'ÂΩ¢ÁãÄÈÅ∏Êìá', test: () => this.testShapeSelection() },
            { name: 'È°èËâ≤ÊéßÂà∂', test: () => this.testColorControls() },
            { name: 'Â§ßÂ∞èË™øÊï¥', test: () => this.testSizeControls() },
            { name: 'ÂãïÁï´Ë®≠ÂÆö', test: () => this.testAnimationSettings() },
            { name: 'ÂìÅË≥™Ë®≠ÂÆö', test: () => this.testQualitySettings() },
            { name: 'ÊñπÂºèÈÅ∏Êìá', test: () => this.testMethodSelection() },
            { name: 'Èù¢ÊùøÊéßÂà∂', test: () => this.testPanelControls() }
        ];

        for (const controlTest of controlTests) {
            try {
                this.log(`Âü∑Ë°å ${controlTest.name} Ê∏¨Ë©¶...`, 'test');
                const result = await controlTest.test();
                this.testResults.controlTests[controlTest.name] = {
                    success: true,
                    result: result
                };
                this.log(`${controlTest.name} Ê∏¨Ë©¶ÂÆåÊàê`, 'success');
            } catch (error) {
                this.log(`${controlTest.name} Ê∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                this.testResults.controlTests[controlTest.name] = {
                    success: false,
                    error: error.message
                };
                this.testResults.issues.push({
                    type: 'error',
                    message: `${controlTest.name} Ê∏¨Ë©¶Â§±Êïó: ${error.message}`
                });
            }
        }
    }

    async testShapeSelection() {
        const shapes = ['circle', 'square', 'triangle', 'star', 'heart'];
        const results = [];
        
        for (const shape of shapes) {
            await this.page.selectOption('#shape', shape);
            await this.page.waitForTimeout(300);
            
            const isVisible = await this.page.isVisible('#canvas');
            results.push({ shape, canvasVisible: isVisible });
        }
        
        return results;
    }

    async testColorControls() {
        const colors = ['#ff0000', '#00ff00', '#0000ff'];
        const results = [];
        
        for (const color of colors) {
            await this.page.fill('#fillColor', color);
            await this.page.fill('#strokeColor', color);
            await this.page.waitForTimeout(300);
            
            const fillValue = await this.page.inputValue('#fillColor');
            const strokeValue = await this.page.inputValue('#strokeColor');
            
            results.push({
                color,
                fillSet: fillValue === color,
                strokeSet: strokeValue === color
            });
        }
        
        return results;
    }

    async testSizeControls() {
        const sizes = [20, 40, 60, 80];
        const results = [];
        
        for (const size of sizes) {
            await this.page.fill('#size', size.toString());
            await this.page.waitForTimeout(300);
            
            const value = await this.page.inputValue('#size');
            const displayValue = await this.page.textContent('#sizeValue');
            
            results.push({
                size,
                valueSet: parseInt(value) === size,
                displayUpdated: displayValue.includes(size.toString())
            });
        }
        
        return results;
    }

    async testAnimationSettings() {
        const settings = [
            { mode: 'loop', type: 'bounce', speed: 1000 },
            { mode: 'enter-exit', type: 'slide', speed: 1500 },
            { mode: 'enter-only', type: 'fade', speed: 2000 }
        ];
        
        const results = [];
        
        for (const setting of settings) {
            await this.page.selectOption('#animationMode', setting.mode);
            await this.page.selectOption('#animationType', setting.type);
            await this.page.fill('#speed', setting.speed.toString());
            await this.page.waitForTimeout(500);
            
            const modeValue = await this.page.inputValue('#animationMode');
            const typeValue = await this.page.inputValue('#animationType');
            const speedValue = await this.page.inputValue('#speed');
            
            results.push({
                setting,
                modeSet: modeValue === setting.mode,
                typeSet: typeValue === setting.type,
                speedSet: parseInt(speedValue) === setting.speed
            });
        }
        
        return results;
    }

    async testQualitySettings() {
        const qualities = ['12', '15', '20'];
        const results = [];
        
        for (const quality of qualities) {
            await this.page.selectOption('#quality', quality);
            await this.page.waitForTimeout(300);
            
            const value = await this.page.inputValue('#quality');
            results.push({
                quality,
                valueSet: value === quality
            });
        }
        
        return results;
    }

    async testMethodSelection() {
        const methods = ['frames', 'ffmpeg'];
        const results = [];
        
        for (const method of methods) {
            const button = await this.page.$(`[data-method="${method}"]`);
            await button.click();
            await this.page.waitForTimeout(300);
            
            const isActive = await button.evaluate(el => el.classList.contains('active'));
            results.push({
                method,
                isActive
            });
        }
        
        return results;
    }

    async testPanelControls() {
        const panels = [
            { button: '#helpBtn', panel: '#helpPanel' },
            { button: '#settingsBtn', panel: '#settingsPanel' }
        ];
        
        const results = [];
        
        for (const panel of panels) {
            // ÈñãÂïüÈù¢Êùø
            await this.page.click(panel.button);
            await this.page.waitForTimeout(300);
            
            const isVisible = await this.page.isVisible(panel.panel);
            
            // ÈóúÈñâÈù¢Êùø
            const closeBtn = await this.page.$(`${panel.panel} .close-btn`);
            if (closeBtn) {
                await closeBtn.click();
                await this.page.waitForTimeout(300);
            }
            
            const isHidden = !(await this.page.isVisible(panel.panel));
            
            results.push({
                panel: panel.panel,
                canOpen: isVisible,
                canClose: isHidden
            });
        }
        
        return results;
    }

    async testPerformance() {
        this.log('Ê∏¨Ë©¶ÊÄßËÉΩË°®Áèæ...', 'test');
        
        const performanceTests = [
            { name: 'Âø´ÈÄüÈÄ£Á∫åËÆäÊõ¥', test: () => this.testRapidChanges() },
            { name: 'Ë®òÊÜ∂È´î‰ΩøÁî®', test: () => this.testMemoryUsage() },
            { name: 'ÈüøÊáâÊôÇÈñì', test: () => this.testResponseTime() }
        ];

        for (const perfTest of performanceTests) {
            try {
                const result = await perfTest.test();
                this.testResults.performanceTests[perfTest.name] = result;
                this.log(`${perfTest.name} Ê∏¨Ë©¶ÂÆåÊàê`, 'success');
            } catch (error) {
                this.log(`${perfTest.name} Ê∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                this.testResults.performanceTests[perfTest.name] = {
                    error: error.message
                };
            }
        }
    }

    async testRapidChanges() {
        const startTime = Date.now();
        
        // Âø´ÈÄüÈÄ£Á∫åËÆäÊõ¥Â§öÂÄãÊéßÂà∂È†Ö
        for (let i = 0; i < 10; i++) {
            await this.page.fill('#size', (20 + i * 5).toString());
            await this.page.fill('#speed', (500 + i * 100).toString());
            await this.page.selectOption('#shape', i % 2 === 0 ? 'circle' : 'square');
        }
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        return {
            duration: duration,
            changesPerSecond: (30 / duration * 1000).toFixed(2)
        };
    }

    async testMemoryUsage() {
        const metrics = await this.page.evaluate(() => {
            if (performance.memory) {
                return {
                    usedJSHeapSize: performance.memory.usedJSHeapSize,
                    totalJSHeapSize: performance.memory.totalJSHeapSize,
                    jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                };
            }
            return null;
        });
        
        return metrics;
    }

    async testResponseTime() {
        const responseTimes = [];
        
        for (let i = 0; i < 5; i++) {
            const startTime = Date.now();
            await this.page.fill('#size', (30 + i * 10).toString());
            await this.page.waitForTimeout(100); // Á≠âÂæÖÈ†êË¶ΩÊõ¥Êñ∞
            const endTime = Date.now();
            
            responseTimes.push(endTime - startTime);
        }
        
        return {
            average: responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length,
            min: Math.min(...responseTimes),
            max: Math.max(...responseTimes),
            all: responseTimes
        };
    }

    async generateReport() {
        const duration = Date.now() - this.startTime;
        
        this.testResults.summary = {
            totalDuration: duration,
            previewUpdateTests: Object.keys(this.testResults.previewUpdates).length,
            controlTests: Object.keys(this.testResults.controlTests).length,
            performanceTests: Object.keys(this.testResults.performanceTests).length,
            totalIssues: this.testResults.issues.length,
            criticalIssues: this.testResults.issues.filter(i => i.type === 'critical').length,
            successfulPreviewUpdates: Object.values(this.testResults.previewUpdates)
                .filter(p => p.successRate > 0.8).length
        };

        // ‰øùÂ≠òÂ†±Âëä
        const reportPath = path.join(__dirname, 'enhanced-preview-test-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(this.testResults, null, 2));
        
        this.log(`Ê∏¨Ë©¶Â†±ÂëäÂ∑≤‰øùÂ≠ò: ${reportPath}`, 'info');
        this.displaySummary();
    }

    displaySummary() {
        console.log('\n' + '='.repeat(80));
        console.log('üîÑ Â¢ûÂº∑È†êË¶ΩÊ∏¨Ë©¶ÊëòË¶ÅÂ†±Âëä');
        console.log('='.repeat(80));
        
        const summary = this.testResults.summary;
        
        console.log(`\n‚è±Ô∏è Ê∏¨Ë©¶ÊôÇÈñì: ${(summary.totalDuration / 1000).toFixed(2)}s`);
        console.log(`üîÑ È†êË¶ΩÊõ¥Êñ∞Ê∏¨Ë©¶: ${summary.previewUpdateTests} ÂÄãÊéßÂà∂È†Ö`);
        console.log(`üéõÔ∏è ÊéßÂà∂È†ÖÊ∏¨Ë©¶: ${summary.controlTests} ÂÄãÂäüËÉΩ`);
        console.log(`‚ö° ÊÄßËÉΩÊ∏¨Ë©¶: ${summary.performanceTests} ÂÄãÈ†ÖÁõÆ`);
        console.log(`‚úÖ ÊàêÂäüÁöÑÈ†êË¶ΩÊõ¥Êñ∞: ${summary.successfulPreviewUpdates}/${summary.previewUpdateTests}`);
        console.log(`‚ö†Ô∏è ÁôºÁèæÂïèÈ°å: ${summary.totalIssues} (Âö¥Èáç: ${summary.criticalIssues})`);

        if (this.testResults.issues.length > 0) {
            console.log('\nüîç ÁôºÁèæÁöÑÂïèÈ°å:');
            this.testResults.issues.forEach((issue, index) => {
                console.log(`  ${index + 1}. [${issue.type.toUpperCase()}] ${issue.message}`);
            });
        }

        console.log('\nüìä È†êË¶ΩÊõ¥Êñ∞ÊàêÂäüÁéá:');
        Object.entries(this.testResults.previewUpdates).forEach(([control, data]) => {
            const rate = (data.successRate * 100).toFixed(1);
            const status = data.successRate > 0.8 ? '‚úÖ' : data.successRate > 0.5 ? '‚ö†Ô∏è' : '‚ùå';
            console.log(`  ${control}: ${rate}% ${status}`);
        });

        console.log('\n' + '='.repeat(80));
    }

    async cleanup() {
        if (this.browser) {
            await this.browser.close();
        }
    }
}

// Âü∑Ë°åÊ∏¨Ë©¶
if (require.main === module) {
    const tester = new EnhancedPreviewTest();
    tester.runTests().catch(console.error);
}

module.exports = EnhancedPreviewTest;
